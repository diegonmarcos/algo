.TH "inc/push_swap.h" 3 "Thu Mar 20 2025 16:00:59" "push_swap" \" -*- nroff -*-
.ad l
.nh
.SH NAME
inc/push_swap.h
.SH SYNOPSIS
.br
.PP
\fC#include 'push_swap_defines\&.h'\fP
.br
\fC#include 'push_swap_data\&.h'\fP
.br
\fC#include '\&.\&./libs/mylibs/mylibc/inc/mylibc\&.h'\fP
.br

.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef enum \fBe_ft_printers_db\fP \fBt_ft_printers_db\fP"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBe_ft_printers_db\fP { \fBSTART\fP, \fBEND\fP, \fBMOVEF\fP, \fBMOVES\fP, \fBSELEC\fP, \fBRADIX\fP, \fBQUICK\fP, \fBGEAR\fP, \fBSPLIT\fP, \fBMERGE_NS\fP, \fBMERGE_AS\fP, \fBPRICES\fP }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "void \fBdata_alloc\fP (int argc, char **argv, \fBt_list_program\fP *list_program)"
.br
.ti -1c
.RI "void \fBft_free_push_swap\fP (\fBt_list_program\fP *list_program, char **argv, \fBt_list_dls\fP *stack_a, int argc)"
.br
.ti -1c
.RI "void \fBft_free_push_swap_end\fP (\fBt_list_program\fP *list_program)"
.br
.ti -1c
.RI "void \fBft_free_push_swap_halt\fP (\fBt_list_program\fP *list_programm)"
.br
.ti -1c
.RI "void \fBsort_stack\fP (\fBt_list_program\fP *list_program)"
.br
.ti -1c
.RI "void \fBselection_sort\fP (\fBt_list_program\fP *list_program)"
.br
.ti -1c
.RI "void \fBselection_sort_recursion\fP (int *pushes, \fBt_list_program\fP *list_program)"
.br
.ti -1c
.RI "void \fBsort_3\fP (\fBt_list_dls\fP **stack_a, \fBt_list_program\fP *list_program)"
.br
.ti -1c
.RI "void \fBselection_sort_merge_back\fP (int *pushes, \fBt_list_program\fP *list_program)"
.br
.ti -1c
.RI "int \fBmin_node_pos\fP (\fBt_list_program\fP *list_program)"
.br
.ti -1c
.RI "void \fBradix_sort_pushswap\fP (\fBt_list_program\fP *list_program)"
.br
.ti -1c
.RI "void \fBradix_sort_step\fP (int bit, int size, \fBt_list_program\fP *list_program)"
.br
.ti -1c
.RI "void \fBquick_sort_pushswap\fP (\fBt_list_program\fP *list_program)"
.br
.ti -1c
.RI "void \fBsort_3_chunk\fP (\fBt_list_program\fP *list_program)"
.br
.ti -1c
.RI "void \fBgear_sort_pushswap\fP (\fBt_list_program\fP *list_program)"
.br
.ti -1c
.RI "void \fBsort_gearing\fP (char stack_from, char stack_to, int base_case, \fBt_list_program\fP *list_program)"
.br
.ti -1c
.RI "void \fBsort_move_lower_cost\fP (char stack_from, \fBt_move_lower_cost\fP *v, \fBt_list_program\fP *list_program)"
.br
.ti -1c
.RI "int \fBnode_pos_locator\fP (int value, \fBt_list_program\fP *list_program, char type, char stack_from)"
.br
.ti -1c
.RI "int \fBsort_gearing_is_base_case\fP (int base_case, \fBt_list_program\fP *list_program)"
.br
.ti -1c
.RI "int \fBnode_pos_locator_is_in_place\fP (char stack_from, int value, \fBt_node_pos_locator\fP *v)"
.br
.ti -1c
.RI "void \fBhigh_up_stack\fP (\fBt_list_program\fP *list_program)"
.br
.ti -1c
.RI "void \fBlow_up_stack\fP (\fBt_list_program\fP *list_program)"
.br
.ti -1c
.RI "int \fBmax_node_finder\fP (\fBt_list_dls\fP **stack, \fBt_list_program\fP *list_program)"
.br
.ti -1c
.RI "void \fBquick_sort_partial\fP (\fBt_list_program\fP *list_program)"
.br
.ti -1c
.RI "void \fBpivot_calculation\fP (\fBt_chunk\fP *chunk_to_sort, \fBt_splits\fP *split_chunks)"
.br
.ti -1c
.RI "void \fBselection_sort_chunk\fP (\fBt_list_program\fP *list_dls_program)"
.br
.ti -1c
.RI "void \fBmoves_optimizations\fP (\fBt_list_program\fP *list_program)"
.br
.ti -1c
.RI "void \fBrotate\fP (char *direction, char stack_name, \fBt_list_program\fP *list_program)"
.br
.RI "Rotates the specified stack\&. "
.ti -1c
.RI "void \fBpush\fP (char direction, \fBt_list_program\fP *list_program)"
.br
.RI "Numbers moved from one stack to another using: push, swap, rotate\&. "
.ti -1c
.RI "void \fBswap\fP (char stack_name, \fBt_list_program\fP *list_program)"
.br
.ti -1c
.RI "void \fBswap_both\fP (\fBt_list_program\fP *\fBt_list_program\fP)"
.br
.ti -1c
.RI "void \fBrotate_both\fP (char *direction, \fBt_list_program\fP *\fBt_list_program\fP)"
.br
.ti -1c
.RI "void \fBmove_stack_fromto\fP (\fBt_position\fP from, \fBt_position\fP to, \fBt_list_program\fP *list_program)"
.br
.ti -1c
.RI "void \fBmove_stack_fromto_case\fP (char *move_case, \fBt_list_program\fP *list_program)"
.br
.ti -1c
.RI "void \fBadd_index_numbers\fP (\fBt_list_dls\fP *list)"
.br
.ti -1c
.RI "int \fBdigits_to_bits\fP (int digits)"
.br
.ti -1c
.RI "int \fBis_sorted_array_int\fP (int *arr, int size)"
.br
.ti -1c
.RI "int \fBis_sorted_linked_list\fP (\fBt_list_dls\fP *stack)"
.br
.ti -1c
.RI "void \fBis_sorted_linked_list_push\fP (\fBt_list_program\fP *list_program)"
.br
.ti -1c
.RI "void \fBprint_results\fP (\fBt_list_program\fP *list_program)"
.br
.ti -1c
.RI "void \fBerror_handling_input_0\fP (int argc, char **argv)"
.br
.ti -1c
.RI "void \fBerror_handling_input_1\fP (\fBt_list_program\fP *list_program)"
.br
.RI "Error handling and egde cases\&. "
.ti -1c
.RI "void \fBsort_stack_dbg\fP (\fBt_list_program\fP *list_program)"
.br
.ti -1c
.RI "void \fBft_printers\fP (\fBt_ft_printers_db\fP s, \fBt_list_program\fP *list_program)"
.br
.ti -1c
.RI "void \fBft_printers_gearsort\fP (\fBt_ft_printers_db\fP s, \fBt_move_lower_cost\fP *v, \fBt_list_program\fP *list_program)"
.br
.ti -1c
.RI "void \fBprinter_dbg_split\fP (\fBt_ft_printers_db\fP s, \fBt_splits\fP *split_chunks, \fBt_list_program\fP *list_program)"
.br
.ti -1c
.RI "void \fBprinter_dbg_split1\fP (\fBt_ft_printers_db\fP s, \fBt_chunk1\fP *split_chunks, \fBt_list_program\fP *list_program)"
.br
.in -1c
.SH "Typedef Documentation"
.PP 
.SS "typedef enum \fBe_ft_printers_db\fP \fBt_ft_printers_db\fP"

.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBe_ft_printers_db\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fISTART \fP\fP
.TP
\fB\fIEND \fP\fP
.TP
\fB\fIMOVEF \fP\fP
.TP
\fB\fIMOVES \fP\fP
.TP
\fB\fISELEC \fP\fP
.TP
\fB\fIRADIX \fP\fP
.TP
\fB\fIQUICK \fP\fP
.TP
\fB\fIGEAR \fP\fP
.TP
\fB\fISPLIT \fP\fP
.TP
\fB\fIMERGE_NS \fP\fP
.TP
\fB\fIMERGE_AS \fP\fP
.TP
\fB\fIPRICES \fP\fP
.SH "Function Documentation"
.PP 
.SS "void add_index_numbers (\fBt_list_dls\fP * list)"

.SS "void data_alloc (int argc, char ** argv, \fBt_list_program\fP * list_program)"

.SS "int digits_to_bits (int digits)"

.SS "void error_handling_input_0 (int argc, char ** argv)"

.SS "void error_handling_input_1 (\fBt_list_program\fP * list_program)"

.PP
Error handling and egde cases\&. 
.PP
\fBDetails:\fP
.RS 4
This module provides functions to handle errors and edge cases in the input for the push_swap program\&. It includes checks for the following:
.RE
.PP
.IP "\(bu" 2
Duplicate values in the input
.IP "\(bu" 2
Non-integer values in the input
.IP "\(bu" 2
Insufficient number of arguments
.IP "\(bu" 2
Empty or null arguments
.IP "\(bu" 2
Already sorted input
.IP "\(bu" 2
Single element input
.IP "\(bu" 2
Sorted linked list in stack_a
.IP "\(bu" 2
Non-empty stack_b
.PP
.PP
\fBFunctions:\fP
.RS 4

.IP "\(bu" 2
error_handling_input_1: for duplicates, non-integers, and sorted input\&.
.IP "\(bu" 2
error_handling_input_0: for the number of arguments and empty arguments\&.
.IP "\(bu" 2
is_sorted_linked_list_push: Checks if stack_a is sorted, if stack_b is empty, and handles memory release for termination\&. 
.PP
.RE
.PP

.SS "void ft_free_push_swap (\fBt_list_program\fP * list_program, char ** argv, \fBt_list_dls\fP * stack_a, int argc)"

.SS "void ft_free_push_swap_end (\fBt_list_program\fP * list_program)"

.SS "void ft_free_push_swap_halt (\fBt_list_program\fP * list_programm)"

.SS "void ft_printers (\fBt_ft_printers_db\fP s, \fBt_list_program\fP * list_program)"

.SS "void ft_printers_gearsort (\fBt_ft_printers_db\fP s, \fBt_move_lower_cost\fP * v, \fBt_list_program\fP * list_program)"

.SS "void gear_sort_pushswap (\fBt_list_program\fP * list_program)"

.SS "void high_up_stack (\fBt_list_program\fP * list_program)"

.SS "int is_sorted_array_int (int * arr, int size)"

.SS "int is_sorted_linked_list (\fBt_list_dls\fP * stack)"

.SS "void is_sorted_linked_list_push (\fBt_list_program\fP * list_program)"

.SS "void low_up_stack (\fBt_list_program\fP * list_program)"

.SS "int max_node_finder (\fBt_list_dls\fP ** stack, \fBt_list_program\fP * list_program)"

.SS "int min_node_pos (\fBt_list_program\fP * list_program)"

.SS "void move_stack_fromto (\fBt_position\fP from, \fBt_position\fP to, \fBt_list_program\fP * list_program)"

.SS "void move_stack_fromto_case (char * move_case, \fBt_list_program\fP * list_program)"

.SS "void moves_optimizations (\fBt_list_program\fP * list_program)"

.SS "int node_pos_locator (int value, \fBt_list_program\fP * list_program, char type, char stack_from)"

.SS "int node_pos_locator_is_in_place (char stack_from, int value, \fBt_node_pos_locator\fP * v)"

.SS "void pivot_calculation (\fBt_chunk\fP * chunk_to_sort, \fBt_splits\fP * split_chunks)"

.SS "void print_results (\fBt_list_program\fP * list_program)"

.SS "void printer_dbg_split (\fBt_ft_printers_db\fP s, \fBt_splits\fP * split_chunks, \fBt_list_program\fP * list_program)"

.SS "void printer_dbg_split1 (\fBt_ft_printers_db\fP s, \fBt_chunk1\fP * split_chunks, \fBt_list_program\fP * list_program)"

.SS "void push (char direction, \fBt_list_program\fP * list_program)"

.PP
Numbers moved from one stack to another using: push, swap, rotate\&. 
.PP
\fBDetails:\fP
.RS 4
This module provides functions to perform various stack operations for the push_swap program\&. It includes the following functionalities:
.RE
.PP
.IP "\(bu" 2
push(A to B or B to A),
.IP "\(bu" 2
swap(A or B or both),
.IP "\(bu" 2
rotate(Tail to head or Next to head, one stack or both at the same time )\&.
.IP "\(bu" 2
Handling edge cases such as empty stacks or stacks with a single element
.PP
.PP
\fBFunctions:\fP
.RS 4

.IP "\(bu" 2
void \fBpush(char direction, t_list_program *list_program)\fP: Moves the top element from one stack to another\&.
.IP "\(bu" 2
void \fBswap(char stack_name, t_list_program *list_program)\fP: Swaps the top two elements of a stack\&.
.IP "\(bu" 2
void \fBrotate(char *direction, char stack_name, t_list_program *list_program)\fP: Rotates a stack in both directions\&. 
.PP
.RE
.PP

.SS "void quick_sort_partial (\fBt_list_program\fP * list_program)"

.SS "void quick_sort_pushswap (\fBt_list_program\fP * list_program)"

.SS "void radix_sort_pushswap (\fBt_list_program\fP * list_program)"

.SS "void radix_sort_step (int bit, int size, \fBt_list_program\fP * list_program)"

.SS "void rotate (char * direction, char stack_name, \fBt_list_program\fP * list_program)"

.PP
Rotates the specified stack\&. 
.PP
\fBDetails:\fP
.RS 4

.IP "\(bu" 2
function rotates the given stack based on the provided direction\&.
.IP "\(bu" 2
The direction 'r' rotates the stack upward (counter-clockwise, head to tail)\&.
.IP "\(bu" 2
The direction 'rr' rotates the stack downward (clockwise, tail to head)\&.
.IP "\(bu" 2
The stack_name 'a' refers to stack_a and 'b' refers to stack_b\&.
.IP "\(bu" 2
If the specified stack is empty or contains only one element, no rotation is performed\&.
.PP
.RE
.PP
\fBUsage:\fP
.RS 4

.IP "\(bu" 2
\fBdirection\fP The rotation direction: 'r' or 'rr'\&.
.IP "\(bu" 2
\fBstack_name\fP The identifier for the stack: 'a' or 'b'\&.
.IP "\(bu" 2
\fBlist_program\fP Pointer to the structure containing the stacks\&.
.IP "\(bu" 2
\fBreturn\fP is void\&. 
.PP
.RE
.PP

.SS "void rotate_both (char * direction, \fBt_list_program\fP * t_list_program)"

.SS "void selection_sort (\fBt_list_program\fP * list_program)"

.SS "void selection_sort_chunk (\fBt_list_program\fP * list_dls_program)"

.SS "void selection_sort_merge_back (int * pushes, \fBt_list_program\fP * list_program)"

.SS "void selection_sort_recursion (int * pushes, \fBt_list_program\fP * list_program)"

.SS "void sort_3 (\fBt_list_dls\fP ** stack_a, \fBt_list_program\fP * list_program)"

.SS "void sort_3_chunk (\fBt_list_program\fP * list_program)"

.SS "void sort_gearing (char stack_from, char stack_to, int base_case, \fBt_list_program\fP * list_program)"

.SS "int sort_gearing_is_base_case (int base_case, \fBt_list_program\fP * list_program)"

.SS "void sort_move_lower_cost (char stack_from, \fBt_move_lower_cost\fP * v, \fBt_list_program\fP * list_program)"

.SS "void sort_stack (\fBt_list_program\fP * list_program)"

.SS "void sort_stack_dbg (\fBt_list_program\fP * list_program)"

.SS "void swap (char stack_name, \fBt_list_program\fP * list_program)"

.SS "void swap_both (\fBt_list_program\fP * t_list_program)"

.SH "Author"
.PP 
Generated automatically by Doxygen for push_swap from the source code\&.
