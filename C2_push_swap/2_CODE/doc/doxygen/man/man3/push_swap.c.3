.TH "src/push_swap/push_swap.c" 3 "Fri Mar 21 2025 18:12:07" "push_swap" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/push_swap/push_swap.c
.SH SYNOPSIS
.br
.PP
\fC#include 'push_swap\&.h'\fP
.br

.SS "Functions"

.in +1c
.ti -1c
.RI "int \fBmain\fP (int argc, char **argv)"
.br
.RI "Implementation of the push_swap project from 42 school\&. "
.in -1c
.SH "Function Documentation"
.PP 
.SS "int main (int argc, char ** argv)"

.PP
Implementation of the push_swap project from 42 school\&. 
.PP
\fBDetails:\fP
.RS 4

.IP "\(bu" 2
The push_swap project is a sorting algorithm project that involves sorting a two stack of integers using stacks operations\&. The goal is to sort the stack with the least number of operations possible\&. The allowed operations are pushing elements between two stacks, rotating or reversing the stacks, and swapping the top elements of the stacks\&.
.PP
.RE
.PP
\fBUsage Program: \&./push_swap [ARGV]\fP
.RS 4

.IP "\(bu" 2
[parm2] \fBargv:\fP unsorted array of integers\&.
.IP "\(bu" 2
return: \fBreturn\fP void 
.PP
.nf
make &&\\
ARG="0 9 8 2 3"; \&./push_swap $ARG | \&./checker_linux $ARG

.fi
.PP

.PP
.RE
.PP
\fBUsage Make: make [option1] [option2] \&.\&.\&.\fP
.RS 4

.IP "\(bu" 2
[static analysis] make linting
.PP
.RE
.PP
.IP "\(bu" 2
[leaks] make leaks
.IP "\(bu" 2
[tester] make testing_alles
.IP "\(bu" 2
[visualizer] make run_visualizer
.IP "\(bu" 2
[tracers] make DBG=1 ALGO=[X] re tests_run_[Y]
.IP "\(bu" 2
[debug] make debug-[Z]
.IP "  \(bu" 4
[verbose] make VERBOSE=1 re
.PP

.IP "\(bu" 2
[X] selec, radix, quick, gear
.IP "  \(bu" 4
[Y] 5, 50, 75, 100, 500
.PP

.IP "\(bu" 2
[Z] vscode, lldb, gdb
.PP
.PP
.PP
.nf
make DBG=1 ALGO=selec re tests_run_5
make DBG=1 ALGO=selec re tests_run_50
make DBG=1 ALGO=radix re tests_run_75
make DBG=1 ALGO=quick re tests_run_100
make DBG=0 ALGO=gear re tests_run_500
.fi
.PP
 
.PP
.nf
make debug\-vscode
make debug\-lldb
make debug\-gdb

.fi
.PP
 
.SH "Author"
.PP 
Generated automatically by Doxygen for push_swap from the source code\&.
