//###################################################################################
// UTILS
//###################################################################################

	/*
	This function calculates the distance between a given
	index and the head of a linked list stack.
	*/

int	index_distance_head(t_list **stack, int index)
{
	t_list	*head;
	int		distance;

	distance = 0;
	head = *stack;
	while (head)
	{
		if (head->index == index)
			break ;
		distance++;
		head = head->next;
	}
	return (distance);
}

	/*
	Finds and returns the minimum value in a linked
	list, excluding a given value.
	*/

int	get_min(t_list **stack, int val)
{
	t_list	*head;
	int		min;

	head = *stack;
	min = head->index;
	while (head->next)
	{
		head = head->next;
		if ((head->index < min) && head->index != val)
			min = head->index;
	}
	return (min);
}

	/*
	Searches for the next minimum value in a stack, represented as a linked list.
	It returns a pointer to the node that contains the minimum value.
	*/

static t_list	*get_next_min(t_list **stack)
{
	t_list	*head;
	t_list	*min;
	int		has_min;

	min = NULL;
	has_min = 0;
	head = *stack;
	if (head)
	{
		while (head)
		{
			if ((head->index == -1) && (!has_min || head->value < min->value))
			{
				min = head;
				has_min = 1;
			}
			head = head->next;
		}
	}
	return (min);
}

	/*
	Assigns an index to each element of a linked list
	stack in ascending order based on their values.
	*/

void	index_stack(t_list **stack)
{
	t_list	*head;
	int		index;

	index = 0;
	head = get_next_min(stack);
	while (head)
	{
		head->index = index++;
		head = get_next_min(stack);
	}
}

	/*
	Checks if a stack of numbers is sorted in ascending order.
	It takes a pointer to the top of the stack and returns an
	integer: 1 if the stack is sorted, and 0 otherwise.
	*/

int	is_sorted(t_list **stack)
{
	t_list	*head;

	head = *stack;
	while (head && head->next)
	{
		if (head->value > head->next->value)
			return (0);
		head = head->next;
	}
	return (1);
}


//###################################################################################
// ALGOS
//###################################################################################
#include "../header/push_swap.h"

	/*
	Calculates the number of bits required to represent the
	largest element in a stack of integers. It takes a pointer
	to a pointer to a t_list structure as input and returns
	the number of bits as an integer.
	*/

static int	get_max_bits(t_list **stack)
{
	t_list	*head;
	int		max;
	int		max_bits;

	head = *stack;
	max = head->index;
	max_bits = 0;
	while (head)
	{
		if (head->index > max)
			max = head->index;
		head = head->next;
	}
	while ((max >> max_bits) != 0)
		max_bits++;
	return (max_bits);
}

	/*
	Function takes two pointers to t_list structures as input and
	sorts the stack using the radix sort algorithm. It first determines
	the maximum number of bits needed to represent the largest element
	in the stack, then iterates through each bit position and performs
	bucket sorting based on that position. Finally, it assembles the
	sorted stack by repeatedly pushing the elements back onto stack A.
	*/

void	radix_sort(t_list **stack_a, t_list **stack_b)
{
	t_list	*head_a;
	int		i;
	int		j;
	int		size;
	int		max_bits;

	i = 0;
	head_a = *stack_a;
	size = ft_lstsize(head_a);
	max_bits = get_max_bits(stack_a);
	while (i < max_bits)
	{
		j = 0;
		while (j++ < size)
		{
			head_a = *stack_a;
			if (((head_a->index >> i) & 1) == 1)
				ra(stack_a);
			else
				pb(stack_a, stack_b);
		}
		while (ft_lstsize(*stack_b) != 0)
			pa(stack_a, stack_b);
		i++;
	}
}


#include "../header/push_swap.h"

	/*
	Takes pointers to two t_list structures as input and sorts the first
	stack containing four elements by performing a series of operations
	that involve pushing elements to a second stack and using the previously
	defined sort_three function.
	*/

void	sort_4(t_list **stack_a, t_list **stack_b)
{
	int	distance;

	if (is_sorted(stack_a))
		return ;
	distance = index_distance_head(stack_a, get_min(stack_a, -1));
	if (distance == 1)
		ra(stack_a);
	else if (distance == 2)
	{
		ra(stack_a);
		ra(stack_a);
	}
	else if (distance == 3)
		rra(stack_a);
	if (is_sorted(stack_a))
		return ;
	pb(stack_a, stack_b);
	sort_3(stack_a);
	pa(stack_a, stack_b);
}

	/*
	Simalar to sort_four, takes two pointers to pointers to t_list
	structures as input and sorts the stack by pushing two elements
	to stack_b, sorting the remaining three elements in stack_a,
	then pushing the two elements back to stack_a.
	*/

void	sort_5(t_list **stack_a, t_list **stack_b)
{
	int	distance;

	distance = index_distance_head(stack_a, get_min(stack_a, -1));
	if (distance == 1)
		ra(stack_a);
	else if (distance == 2)
	{
		ra(stack_a);
		ra(stack_a);
	}
	else if (distance == 3)
	{
		rra(stack_a);
		rra(stack_a);
	}
	else if (distance == 4)
		rra(stack_a);
	if (is_sorted(stack_a))
		return ;
	pb(stack_a, stack_b);
	sort_4(stack_a, stack_b);
	pa(stack_a, stack_b);
}

	/*
	Checks the size of the stack and calls a corresponding sorting
	function to sort the stack, including sort_three, sort_four, and
	sort_five. If the stack is already sorted, or if the size is 0 or 1,
	the function returns without performing any operations.
	*/

void	simple_sort(t_list **stack_a, t_list **stack_b)
{
	int	size;

	if (is_sorted(stack_a) || ft_lstsize(*stack_a) == 0
		|| ft_lstsize(*stack_a) == 1)
		return ;
	size = ft_lstsize(*stack_a);
	if (size == 2)
		sa(stack_a);
	else if (size == 3)
		sort_3(stack_a);
	else if (size == 4)
		sort_4(stack_a, stack_b);
	else if (size == 5)
		sort_5(stack_a, stack_b);
}


#include "../header/push_swap.h"

	/*
	The next 3 cases bellow are specific cases only.
	*/

static void	sort_132(t_list **stack_a)
{
	ra(stack_a);
	sa(stack_a);
	rra(stack_a);
}

static void	sort_231(t_list **stack_a, t_list *head, int min)
{
	if (head->next->index == min)
		sa(stack_a);
	else
		rra(stack_a);
}

static void	sort_312(t_list **stack_a, t_list *head, int min)
{
	if (head->next->index == min)
		ra(stack_a);
	else
	{
		sa(stack_a);
		rra(stack_a);
	}
}

	/*
	Sorts a stack of three numbers by selecting the appropriate sorting
	method based on their indices. Uses get_min, is_sorted, and
	sort_132, sort_231, and sort_312 to sort the stack.
	Its done this way so it can be used in the bigger algorithm.
	*/

void	sort_3(t_list **stack_a)
{
	t_list	*head;
	int		min;
	int		next_min;

	head = *stack_a;
	min = get_min(stack_a, -1);
	next_min = get_min(stack_a, min);
	if (is_sorted(stack_a) == 1)
		return ;
	if (head->index == min && head->next->index != next_min)
		sort_132(stack_a);
	else if (head->index == next_min)
		sort_231(stack_a, head, min);
	else
		sort_312(stack_a, head, min);
}

