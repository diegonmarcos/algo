# Algos

## BRIEF
Proposes:
- Performance Optimization
- Problem-Solving
- Code Quality
- Data Structures
- System Design

Techniques:
- Dynamic Programming Algorithms**
- Backtracking Algorithms
- Greedy Algorithms
- Concurrent Algorithms
- Sorting and Searching Algorithms (Beyond Basic Ones)
- Graph Algorithms (Advanced)
- String Algorithms
- Geometric Algorithms
- Randomized Algorithms
- Approximation Algorithms
- Caching Algorithms
 
 <br> <br> <br>

## INDEX
**1. Performance Optimization Algorithms:**

* **Goal:** To improve the speed, efficiency, and resource utilization of software.
* **Examples:**
    * **Sorting and Searching:**
        * Timsort, Radix Sort, Binary Search
    * **Data Structures:**
        * Hash Tables, Balanced Binary Search Trees (AVL, Red-Black), Concurrent Data Structures
    * **Caching:**
        * LRU, LFU
    * **Graph Algorithms:**
        * Dijkstra's Algorithm (shortest paths), Network Flow Algorithms
    * **String Matching:**
        * KMP, Boyer-Moore
    * **Randomized Algorithms:**
        * Quickselect
    * **Concurrent Algorithms:**
        * Parallel Sorting, Thread Pools

**2. Problem-Solving Algorithms:**

* **Goal:** To provide solutions to specific computational problems.
* **Examples:**
    * **Dynamic Programming:**
        * Knapsack Problem, Edit Distance, LCS
    * **Backtracking:**
        * N-Queens, Sudoku Solver, Maze Solving
    * **Greedy Algorithms:**
        * Activity Selection, Huffman Coding, Minimum Spanning Tree (Prim's, Kruskal's)
    * **Graph Algorithms:**
        * Topological Sort, Graph Coloring, Traveling Salesman Problem (approximations)
    * **Geometric Algorithms:**
        * Convex Hull, Line Segment Intersection, Closest Pair Problem

**3. Code Quality and Maintainability Algorithms/Techniques:**

* **Goal:** To produce code that is clear, concise, and easy to understand and maintain.
* **Examples:**
    * **Refactoring Algorithms/Techniques:**
        * Code simplification, modularization, and design pattern implementation.
    * **Data Structure Design:**
        * Choosing appropriate data structures for specific tasks.
    * **Algorithmic Design Patterns:**
        * Divide and conquer, dynamic programming, etc.
    * **Well documented code.**
    * **Test driven development techniques.**

**4. Data Structure and Data Management Algorithms:**

* **Goal:** To efficiently organize, store, and retrieve data.
* **Examples:**
    * **Hash Functions and Collision Resolution:**
    * **Tree Traversal:**
        * Inorder, preorder, postorder
    * **Graph Representations:**
        * Adjacency lists, adjacency matrices
    * **Trie Data Structure:**
    * **Heap Data Structure:**

**5. System Design and Scalability Algorithms:**

* **Goal:** To design and implement scalable, robust, and distributed systems.
* **Examples:**
    * **Distributed Consensus Algorithms:**
        * Paxos, Raft
    * **MapReduce:**
    * **Load Balancing Algorithms:**
    * **Caching Strategies:**
    * **Network Routing Algorithms:**
    * **Concurrency Control:**
        * Readers-Writers problem solutions.
    * **Message Queues Algorithms.**

**Key Considerations:**

* Many algorithms serve multiple purposes. For example, Dijkstra's algorithm optimizes performance (shortest paths) and solves a specific problem.
* The context in which an algorithm is used determines its primary purpose.
* Algorithms that create a better software design, also improve code quality.
* Understanding these purpose-based categories helps software engineers select the right algorithms for their specific needs.
